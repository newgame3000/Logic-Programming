# Реферат
## по курсу "Логическое программирование"

### студент: Воронов К.М.

# Логические языки как путь к автоматическому решению задач компьютером

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение
 >«У всякой эпохи есть свои задачи, и их решение обеспечивает прогресс человечества»   -  Генрих Гейне.

На протяжении всей истории человечество сталкивалось с теми или иными задачами, и всегда стоял вопрос, как их решать. В этом вопросе на помощь приходила математика. Уже в Древнем Египте, Греции и других странах во всю решали задачки с использованием алгебры и геометрии. И даже сейчас любой школьник (кроме, конечно, двоечника) с легкостью расскажет теорему Пифагора. Но время шло, задачи становились всё более тяжёлыми, требовалось всё больше непростых вычислений. Люди пытались упростить их создавая разные приспособления: начиная счётами и заканчивая современными компьютерами. Но если со счётами человек всё-таки считает сам, то с компьютером другое дело. Нужен был какой-то способ объяснить машине, что и как надо делать. Так и появились языки программирования. Но и к этому вопросу подошли по-разному.  Существует несколько парадигм программирования, вот некоторые из них: логическое, императивное. Императивное предусматривает выполнение неких введённых инструкций. Но проблема состоит в том, что надо знать и уметь, как задавать такие инструкции. Математик не сможет без должных умений записать эти инструкции для решения определённой задачи. Но тут на подиум выходит логическое программирование. Оно позволяет подойти к программированию и решению задач с точки зрения математики.


## Структура логического программирования на примере языка Prolog

>«У всякого безумия есть своя логика.»  - Уильям Шекспир.

Первый логический язык программирования -  Planner -  появился в 1969 году. Но более популярным стал Prolog, разработанный Аленом Кольмеро в 1971 году. Это самый популярный язык не использующийся в реальном программировании. Он основан на так называемых «дизъюнктах Хорна»: (a&b&..&z)->u,  то есть из верности a,b,...,z следует u. Вот, например, простейший предикат, проверяющий положительное ли число:
```
positive(X):- X>0.  
```
То есть при запросе positive(-1) условие -1>0 не выполняется и Prolog нам выведет false. А при запросе positive(1) будет соответственно true. Такой подход к программированию очень удобно воспринимать математикам, ведь фактически всё это предикаты первого порядка. Очень часто достаточно лишь ввести условие задачи и Prolog сам найдёт решение. Но не всё так гладко. Например, если написать рекурсивный предикат Prolog в математическом виде, провести эквивалентные операции и записать обратно, то можно столкнуться с ситуацией, когда в бесконечном дереве решений Prolog будет находиться решение, но до него программа никогда не дойдёт. Однако в других логических языках, например, Datalog, такие программы могут выполняться правильно. Вообще существует два вида семантики логических программ: декларативная (формула логики предикатов) и процедурная (на основе механизма вывода логического интепретатора). При написании программы, например, на Prolog, надо обращать внимание на них оба. Также Prolog при решении задач часто рассматривает все варианты состояний, что занимает много времени и памяти. Так, для предиката, который описывает условия задачи, он начнёт перебирать все решения и возвращаться в случае неуспеха. А в случае успеха соответственно выведет ответ или true, в зависимости от аргументов предиката.


## Реализация некоторых задач на Prolog
>«Задача решена — ура!
Землекопа — полтора!» Витя Перестукин из м/ф "В стране невыученных уроков."


Так какие же задачи очень удобно решать с помощью логического программирования, а в частности с помощью языка Prolog? Так как его структура строится на построении предикатов, нам подходят задачи, где можно описать некоторые определения, пользуясь которыми можно найти решение. Рассмотрим, например, такую логическую задачу:



Перед началом шахматного матча болельщики обсуждали шансы сильнейших участников предстоящего состязания: Пешкина, Ладейникова, Королева и Слонова. Все сходились на том, что этой четверке обеспечены первые 4 места в турнирной таблице. А более подробные прогнозы болельщики предпочитали высказывать в несколько туманной форме. Вот что они говорили:

    1-й болельщик: Все они наберут разное количество очков. Дележки мест в таблице не будет. Если Пешкин не займет первое место, то Королеву достанется лишь четвертое.
    2-й болельщик: Если Королев займет третье место, то Пешкин займет четвертое. Но у Пешкина положение в турнирной таблице должно быть лучше, чем у Слонова.
    3-й болельщик: Если Ладейников не завоюет первое место, тогда Пешкин выйдет на третье место. А если Королеву удастся занять второе место, то Слонов, конечно, не будет на четвертом месте.
    4-й болельщик: Если Королев займет первое место, то вторым будет Слонов. А если Слонов не будет на втором месте, то и Ладейников не займет второго места.

И представьте себе, ни один из прогнозов не разошелся с истинным результатом матча. Кто какие места занял?

Как уже говорилось выше, нам достаточно просто выписать условия каждого из болельщиков, это можно сделать вот таким образом: 
```Prolog
sorev1_1(P,L,K,S):-P=\=L,P=\=K,P=\=S,L=\=K,L=\=S,S=\=K.

sorev1_2(P,_,K,_):-P=\=1,!, K is 4.
sorev1_2(_,_,_,_).

sorev2_1(P,_,K,_):-K is 3,!,P is 4.
sorev2_1(_,_,_,_).

sorev2_2(P,_,_,S):-P<S.

sorev3_1(P,L,_,_):-L=\=1,!,P is 3.
sorev3_1(_,_,_,_).

sorev3_2(_,_,K,S):- K is 2,!,S=\=4.
sorev3_2(_,_,_,_).

sorev4_1(_,_,K,S):- K is 1,!, S is 2.
sorev4_1(_,_,_,_).

sorev4_2(_,L,_,S):-S=\=2,!,L=\=2.
sorev4_2(_,_,_,_).
```

Каждый из описанных предикатов должен получать на вход четыре переменные: P,L,K,S , которые обозначают первые буквы фамилий участников и описывать их состояния. Возьмём, например, высказывание третьего болельщика. Так как оно описывает два условия, то ему сопоставлены два предиката. Для первого, sorev3_1, имеют важность только первые два участника. Мы соотвественно пишем, как только Ладейников не равен единице (остановится на этом момента нам помогает отчесение, обозначенное '!'), мы указываем, что Пешкин займёт третье. По такому же принципу написаны и другие предикаты. Теперь же нам остаётся все эти условия как-то объединить, для это напишем ещё один предикат:

```
mesta(P,L,K,S):-
T=[1,2,3,4], member(P,T), member(L,T), member(K,T), member(S,T),
sorev1_1(P,L,K,S),sorev1_2(P,L,K,S),sorev2_1(P,L,K,S), sorev2_2(P,L,K,S), sorev3_1(P,L,K,S), sorev3_2(P,L,K,S),sorev4_1(P,L,K,S), sorev4_2(P,L,K,S).
```
Тут мы также принимаем на вход те же самые переменные, с помощью стандартного предиката member указываем, что они принадлежат списку, состоящему из четырёх элементов - с первого по последнее место соответственно, и вызываем все остальные предикаты условий. Готово. Prolog начнёт перебирать все возможные варианты и в конце выведет нам вот такой ответ: 
```
?- mesta(P,L,K,S).
P = 2,
L = 1,
K = 4,
S = 3 ;
false.
```

Если же запустить этот предикат с использованием trace, мы подробно увидим, как он действует. Реализовать такую задачу на каком-нибудь императивном языке, например, на С, было бы не так просто. Легкая реализация этой задачи на Prolog обусловлена очень удобной её интерпретации с точки зрения математики, а именно логики предикатов. Как Вы могли заметить, мы воспользовались спискам, и отдельно не указывали, какой тип имеют переменные. Это еще одно преимущество Prolog по сравнению с императивными языками. Раз уж речь зашла о списках, стоит упомянуть, что мы можем также реализовывать задачи с поиском в глубину или ширину. Рассмотрим ещё одну головоломку:

Вдоль доски расположено 8 лунок, в которых лежат 4 черных и 3 белых шара. Передвинуть черные шары на место белых, а белые - на место черных. Шар можно передвинуть в соседнюю с ним пустую лунку, либо в пустую лунку, находящуюся непосредственно за ближайшим шаром. При этом черные шары можно передвигать только вправо, а белые - только влево.

Если мы представим, что вершины графа - это состояния головоломки, а ребра между ними - это нечто, что меняет эти состояния, то мы можем реализовать поиски в глубину и ширину у этого графа.  Для начала запишем все правила передвижения шаров, описав их в ситуациях с тремя местами (b - black, e - empty, w - white):

```Prolog

go([b,e,w],X):- X=[b,w,e]; X=[e,b,w].

go([b,e,b],X):- X=[e,b,b].
go([b,b,e],X):- X=[b,e,b].
go([w,b,e],X):- X=[w,e,b].

go([w,e,w],X):- X=[w,w,e].
go([e,w,w],X):- X=[w,e,w].
go([e,w,b],X):- X=[w,e,b].

go([b,w,e],X):- X=[e,w,b].
go([e,b,w],X):- X=[w,b,e].

```

Теперь мы можем записать сам предикат смены состояний, он будет выглядеть следующим образом: 
```
move(At,To):- append(X,[A,B,C|T],At), go([A,B,C],G), append(X,G,H), append(H,T,To).
```
С помощью append мы делим наш изначальный список на 2, пытаемся применить одно из правил описанных выше и соединяем обратно другими append. Описав таким образом головоломку через граф, можно переходить непосредственно к поиску. Начнём с поиска в ширину, основанному на очереди. Будем продлевать пути всеми возможными способами и класть в конец очереди. Если путь зашёл в тупик, то будем удалять такой из неё. Таким образом, перебрав все варианты, мы решим задачу.  Предикат prolonged будет "прокладывать путь", то есть совершать смену состояния и проверять, что такого состояния не было раньше, чтобы не происходило зацикливание.
```
prolong([X|T],[Y,X|T]):- move(X,Y), not(member(Y,[X|T])).
```

Далее напишем предикат path, который будет включать в себя начальное состояние Х, конечное состояние Y и путь P. Он будет запускать предикат bdth, наш поиск в ширину, основанный на очереди, где первый аргумент является списком списков, а второй и третий остаются теми же. Опишем также конец этого поиска, когда мы достигли конечного состояния. Потом же мы описываем непосредственно шаг поиска, то есть берём первый элемент в очереди, продляем его и помещаем в конец очереди. И если у нас появился непродляемый путь, то мы удаляем его из очереди и продолжаем поиск с хвоста очереди. 

```Prolog
path(X,Y,P):- bdth([[X]],Y,P),write(P).

bdth([[X|T]|_],X,[X|T]).
bdth([P|QI],X,R):- findall(Z,prolong(P,Z),T),
                   append(T,QI,QO),!,
                   bdth(QO,X,R).

bdth([_|T],Y,L):- bdth(T,Y,L).
```

Заметим, что если поменять местами T и QI, тем самым добавлять вновь полученные пути не в конец очереди, а в начало очереди, то поиск в ширину превратится в поиск в глубину. В итоге, задав начальное и конечное состояние головоломки, Prolog нам выведет список списков - переходы, ведущие к решению.
```Prolog
?- path([b,b,b,b,e,w,w,w],[w,w,w,e,b,b,b,b],X).
X = [[w,w,w,e,b,b,b,b],[w,w,e,w,b,b,b,b],[w,w,b,w,e,b,b,b],[w,w,b,w,b,e,b,b],[w,w,b,e,b,w,b,b],[w,e,b,w,b,w,b,b],[e,w,b,w,b,w,b,b],[b,w,e,w,b,w,b,b],[b,w,b,w,e,w,b,b],[b,w,b,w,b,w,e,b],[b,w,b,w,b,w,b,e],[b,w,b,w,b,e,b,w],[b,w,b,e,b,w,b,w],[b,e,b,w,b,w,b,w],[b,b,e,w,b,w,b,w],[b,b,b,w,e,w,b,w],[b,b,b,w,b,w,e,w],[b,b,b,w,b,e,w,w],[b,b,b,e,b,w,w,w],[b,b,b,b,e,w,w,w]]

```  

## Выводы

>«Никогда не доверяй компьютеру, который не можешь выбросить из окна.» - Стив Возняк.

Prolog - удивительный язык программирования! С одной стороны, он не подходит для решения каких-то крупномасштабных задач, но для решения каких-либо бытовых очень даже. В своё время его даже использовали в сфере искусственного интеллекта. Но что же насчёт логического программирования в целом? Мне кажется, что это очень перспективное направление. Возможно в столь недалёком будущем оно добьётся большого успеха, так как подход к задачам с точки зрения математики очень удобен, ведь на этой науке держится всё, например, физика, информатика и др. Развитие этой области принесёт немалые успехи науки в будущем.

# Список литературы 


1.Prolog — удивительный язык программирования [Электронный ресурс]
URL: https://habr.com/ru/post/124636/ (дата обращения 14.12.2020).

2.Что такое логическое программирование и зачем оно нам нужно [Электронный ресурс]
URL:https://habr.com/ru/post/322900/ (дата обращения 14.12.2020).

3.Логическое программирование [Электронный ресурс]
URL:https://ru.wikipedia.org/wiki/%D0%9B%D0%BE%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5 (дата обращения 14.12.2020).

4.Лекции Сошникова Д.В. и Левинской М.А. Московский авиационных институт.