# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Воронов К.М.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |        5-       |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Списки в языке Пролог несильно отличаются от списков в других языках программирования. Они представляются в виде так называемой головы и хвоста, которые тоже могут являться списками. Это очень похоже на обычный односвязный список в С, где все элементы связаны с помощью указателей. Единственное, в Прологе не надо указывать тип хранимых элементов, что упрощает решение задачи. 

## Задание 1.1: Предикат обработки списка

Стандартные предикаты

Предикат len проходится по списку и считает количество элементов в нём, mem - проверяет принадлежность элемента списку, app - делит список на два всеми возможными способами, rem - удаляет элемент из списка, per - находит все перестановки в списке, а sub - все подсписки.

```prolog
len([],0).
len([H|T],N):- len(T,A), N is A + 1. 

mem([H|T],H).
mem([A|T],H):- mem(T,H).

app([],X,X).
app([H|T],A,[H|B]):- app(T,A,B).

rem(X,[X|T],T).
rem(X,[H|T],[H|B]):- rem(X,T,B).

per([],[]).
per([H|T],X):- rem(H,X,A), per(T,A).

sub(S,H):- app(A,C,H),app(S,B,C).
```
Добавить описание предикатов

`remnstd(L,X,N)` - этот предикат удаляет N последних элементов с помощью стандартных функций. Мы разбиваем список L с помощью app на два списка: X и Y, и указываем, что длина Y составляет N элементов. Таким образом, нужный нам список - X.

Примеры использования:
```prolog
?- remnstd([1,6,4,2,4],X,3).
X = [1, 6] .
?- remnstd([1,6,4,2,4],[1,6,4],N).
N = 2.
?- remnstd([1,2,3],[1,2,3],0).
true.
```

Реализация:
```prolog
remnstd(L,X,N):- app(X, Y, L), len(Y, N).
```

`myremn([L|H],[L|A],N)` - этот предикат также удаляет N последних элементов, но без использования стандартных функций, а с помощью рекурсии. Идея его реализации состоит в проверке условия удаления последних N элементов. Пролог же может восстановить нужный нам список. Для начала удалим по одному элементу из первого и второго списка, пока второй не будет пустой. Далее оставшийся первый должен быть размера N, для проверки этого мы удаляем по одному элементу и считаем их, пока он не станет пуст.

Примеры использования:
```prolog
?- myremn([1,2,3],X,3).
X = [] .
?- myremn([],X,3).
false.
?- myremn([1,2,3],[1,2,3],3).
false.
```
Реализация:
```prolog
myremn([],[],0).
myremn([L|H],[],N):-myremn(H,[],N2), N is N2 + 1.
myremn([L|H],[L|A],N):-myremn(H,A,N).

```

Можно реализовать проще

## Задание 1.2: Предикат обработки числового списка

`maxstd(L,N)` - этот предикат находит позицию максимального элемента с использованием стандартных функций. Нумерация позиций начинается с 0. Идея реализации этого предиката - проверка нужного нам условия. Мы делим список на два, один из которых длины N и считаем, что в голове второго лежит максимальный. Далее просто проходим по всему изначальному списку с помощью предиката max проверяем, что этот элемент больше остальных.

Примеры использования:
```prolog
?- maxstd([1,2,3,6,50,2,8],N).
N = 4 .
?- maxstd([],N).
false.
```
Реализация:
```prolog
maxstd(L,N):- app(H,[A|_],L), len(H,N), max(A,L).

max(A,[]).
max(A,[L|H]):- max(A,H), A>=L.
```

`mymax(L,N)` - этот предикат находит позицию максимального элемента без использования стандартных функций. Он является оболочкой для предиката `max2(L,N,X).`, в который ещё входит сам максимальный элемент - X. Если список состоит из одного элемента, то этот элемент максимальный. Если первый элемент Х больше следующего элемента, то удаляем следующий из списка. Если же нет, то он удаляет первый элемент и сдвигается. Элементы также номеруются с 0.

Примеры использования:
```prolog
?- mymax([1,2,3,5,2,1],N).
N = 3 .
?- mymax([1,1,1,1],N).
N = 0 ;
N = 1 ;
N = 2 ;
N = 3 ;
false.
```
Реализация:
```prolog
mymax(L,N):- max2(L,N,X).

max2([X],0,X).
max2([X,Y|T], 0, X) :- X >= Y, max2([X|T], 0, X).
max2([H|T], N, X) :- max2(T, N1, X), N is N1 + 1, X >= H.
```

`zamena(X,Y,N,T)` - этот предикат получает на вход два списка X и Y, а также число N. Далее он удаляет из X N последних элементов c помощью myremn и поставляет вместо них список Y c помощью app. Результат хранится в T.

Примеры использования:
```prolog
?- zamena([1,2,3,4],[89,56],3,X).
X = [1, 89, 56].
?- zamena([1],[2],1,X).
X = [2] .
```

Реализация:
```prolog
zamena(X,Y,N,T):-myremn(X,L,N), app(L,Y,T).
```

## Задание 2: Реляционное представление данных

Реляционное представление данных имеет как плюсы, так и минусы. С одной стороны, очень удобно смотреть на данные локально, но с другой не видно картины в целом. Например, представление моего варианта `grade(GROUP, STUD, SUBJECT, MARK)` даёт полную информацию о каждом студенте, но не очень удобно воспринимать их всех. Чтобы посмотреть оценки студентов по определённому предмету, надо обойти все такие предикаты, что займёт некоторое время. 


`sr_ball(T,N)` - этот предикат находит средний балл по каждому из предметов. Для этого с помощью bagof создадим список с оценками по данному предмету. Далее посчитаем длину этого списка с помощью предиката len, сумму элементов с помощью sum и разделим сумму на количество. Это и будет средний балл.

Примеры использования:
```prolog
?- sr_ball(X,Y).
X = 'Английский язык',
Y = 3.75 ;
X = 'Информатика',
Y = 3.9285714285714284 ;
X = 'Логическое программирование',
Y = 3.9642857142857144 ;
X = 'Математический анализ',
Y = 3.892857142857143 ;
X = 'Психология',
Y = 3.9285714285714284 ;
X = 'Функциональное программирование',
Y = 3.9642857142857144.
```

Реализация:
```prolog
len([],0).
len([H|T],N):- len(T,A), N is A + 1. 

sum([],0).
sum([H|T],N):- sum(T,A), N is A + H.

sr_ball(T,N):- bagof(X,A^B^grade(A,B,T,X),L), len(L,F), sum(L,K), N is K/F.
```

`ne_sdalgr(G,T)` - этот предикат считает количество не сдавших студентов в каждой группе. Также с помощью bagof создаём новый список, удовлетворяющий условиям(нужной нам группы и оценке 2), и находим его длину с помощью len.


Примеры использования:
```prolog
?- ne_sdalgr(X,Y).
X = 101,
Y = 2 ;
X = 102,
Y = 5 ;
X = 103,
Y = 4 ;
X = 104,
Y = 2.
```
Реализация:
```prolog
ne_sdalgr(G,T):- bagof(2,A^B^grade(G,A,B,2),L), len(L,T).
```

`ne_sdalpr(X,T)` - этот предикат считает количество не сдавших студентов по каждому предмету. Работает аналогично прошлому предикату.

Примеры использования:
```prolog
?- ne_sdalpr(X,Y).
X = 'Английский язык',
Y = 4 ;
X = 'Информатика',
Y = 2 ;
X = 'Логическое программирование',
Y = 2 ;
X = 'Математический анализ',
Y = 3 ;
X = 'Психология',
Y = 1 ;
X = 'Функциональное программирование',
Y = 1.
```

Реализация:
```prolog
ne_sdalgr(G,T):- bagof(2,A^B^grade(G,A,B,2),L), len(L,T).
```

## Выводы

Данная лабораторная работа заставила меня посмотреть на программирование с другой стороны. Меня очень поразило и восхитило умение многих предикатов работать в обе стороны, а также их возможность не только находить что-то, но и проверять. Также мне понравилось, что Пролог работает без указания типа данных, что очень упрощает решение задачи. Я научился работать со списками, а также с реляционными данными. Мне кажется, идея создания логических языков программирования очень перспективна. Даже несмотря на то, что здесь возникают некоторые несостыковки и сложности, в будущем такие языки смогут найти более широкое применение. Не зря Пролог самый популярный язык, который не используется в реальном программировании. Реализация решения задачи с помощью математики очень удобна. 






