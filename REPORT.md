#№ Отчет по лабораторной работе №4
## по курсу "Логическое программирование"

## Обработка естественного языка

### студент: Воронов К.М.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Для обработки естественных и искусственных языков обычно применяется два подхода: статический и лингвистический. Идея первого основывается на том, что в тексте есть наиболее встречающиеся слова, которые надо посчитать. Второго же - анализ: отдельных слов и морфологической характеристики слов, поиск зависимостей слов в предложении и смысл высказывания. Такие задачи легко решать на Прологе, потому что с помощью предикатов мы и задаём зависимости и правила. 
 
## Задание

Реализовать грамматический разбор фраз на ограниченном естественном языке и преобразовать данные фразы  в языки счисления предикатов первого порядка типа:
Запрос: ?- test([every, man, that, lives, loves, a, woman],Res).
Результат: Res = all(X, man(X) & lives(X) => exists(Y, woman(Y) & loves(X, Y))) 

## Принцип решения

Для начала я определяю словари, проверки принадлежности к ним и операторы &,=>.

```prolog
s_list(['man','woman']).
g_list(['lives','loves']).
t_list(['that']).

an_s1(B):- s_list(H), member(B,H).
an_t(A):- t_list(H),  member(A,H).
an_g(A):- g_list(H),  member(A,H).

:- op(200, xfy, '&').
:- op(201, xfy, '=>').
```

Основная структура в этом задании - существительное, глагол, существительное. Но перед существительным будет стоять либо 'every', либо 'a', и если после существительного стоит 'that', то это будет означать, что нужен ещё один глагол. 
С помощью предиката test, который принимает на вход исходный список и выдаёт результат Res, мы делим список предикатом append на два: один отправляем в предикат an_s(анализ существительного), а другой в an_gs(анализ,глагол существительное). Предикат an_s принимает на вход сам список, переменную, которая в данный момент будет выводиться на экран, переменную A, в которой будет храниться, с какой оболочкой мы работаем(all, exist) и B, где будет результат работы данного предиката(часть того, что выводится на экран). Предикат an_gs принимает список, и также переменную Х с результатом. В конце в Res запишем объединение этих ответов с оператором =>, это и выведется на экран.

```prolog 
test(T,Res):- append(T1,T2,T), an_s(T1,'X',A,B), an_gs(T2,X), Res=..[A,'X',B=>X].
```

Предикат an_s анализирует четыре  случая: 'every'(или 'a') существительное, 'every' (или 'a') существительное that глагол. В первых двух случаях мы просто определяем оболочку (в зависимости от 'every' или 'a') и записываем в результат существительное от Х или Y. В остальных случаях записываем существительное & глагол(все от Х или Y).

```prolog 
an_s([T1,T2,T3,T4],X,A,C):- an_s([T1,T2],X,A,B), an_t(T3), an_g(T4), D=..[T4,X], C = B & D.
an_s(['every',T2],X,all,B):- an_s1(T2), B=..[T2,X].
an_s(['a',T2],X,exist,B):- an_s1(T2), B=..[T2,X].
```
 
Предикат an_gs один элемент списка отправляет в an_g, а второй в an_s. Потом собираем результат в оболочке A.

```prolog 
an_gs([Z1|Z2],X):- an_g(Z1), an_s(Z2,'Y',A,B), H=..[Z1,'X','Y'], X=..[A,'Y',B & H].
```

## Результаты

```prolog
?- test([every, man, that, lives, loves, a, woman],Res).
Res = all('X', man('X')&lives('X')=>exist('Y', woman('Y')&loves('X', 'Y'))) .


?- test([every, man, that, lives, loves, a, woman],Res).
Res = all('X', man('X')&lives('X')=>exist('Y', woman('Y')&loves('X', 'Y'))) .

```

## Выводы

Данная лабораторная заставила меня взглянуть на структуру слов в предложениях. Редко задумывался о том, какие слова стоят друг за другом, особенно в предикатах. Также было интересно, каким образом можно решить данную задачу на Прологе. Первая мысль была записать всё строкой, так как Пролог воспринимает заглавные буквы, как переменные, но тогда рассматривался единственный способ расстановки слов, да и не избежать двойных кавычек "". В итоге воспользовался закономерностью расстановки слов в предикатах, что позволило расширить круг обрабатываемых списков, но пришлось заключать заглавные буквы в одинарные кавычки '', без этого никуда не деться. Также никуда не деться без словарей, что тоже не очень удобно. С другой стороны, в Прологе очень легко реализовывать закономерности, сначала мы разделили на существительное и глагол существительное, потом разделили второе на глагол и существительное. Фактически мы это и написали, в каком-нибудь императивном языке, мне кажется, это бы выглядело сложнее.

 




